Iura
ну поехали
во-первых, я немного изменил функцию timestamp() - теперь она выдает более точное время. Правда это сейчас не играет роли.
во-вторых, я позамерял время, за которое выполняется этот факториал, оказывается, внешний цикл нелинейно влияет на внутренний
только внутренний цикл в одиночку у меня выполнился почти за 3 микросекунды
а умноженный на 1000 всего за 12 микросекунд
Iura
в общем отчет:
Одно из узких мест, это то, что слишком часто вызывается функции timestamp()
Профайлер показал, что на нее тратится 58 процентов времени выполнения.
Что такое профайлер https://www.maketecheasier.com/profile-c-program-linu..

Я заменил в функции модуль этот вызов на проверку глобальной переменной, которую проставляю в ss модуле.
Стало немного быстрее. Теперь профайлер показывает 40 процентов.
Также я чуть-чуть поменял функции обработки сообщения, стало немного точнее.

Я не закреплял больше одного треда за ядром, так как не знаю как это делать. Также я не выставлял приоретет процессу. Завтра проверь мою прогу вместе с этими добавками.

Итог: стало немного лучше, но по-прежнему наилучший эффект дает закрепление процесса за ядром.
Я думаю, что это связано с тем, что треды могут переключаться в различном порядке, иногда невыгодном. Например, 2 треда могут друг на друга переключать, а про остальных забыть.
Так что как ни крути, без закрепления не обойтись.
Fichier main.cpp
www.maketecheasier.com
How to Profile a C program in Linux using GNU gprof - Make Tech Easier
Code profiling lets you identify bottlenecks, dead code, and bugs. For a Linux programmer, the GNU profiler..
в качестве бонуса, граф выполнения программы, сгенеренный с помощью вот этой штуки https://github.com/jrfonseca/gprof2dot
из вывода профайлера.
 
	
jrfonseca/gprof2dot
github.com
gprof2dot - Converts profiling output to a dot graph.
картинка не хочет прикрепляться(
ну и фиг с ней
все, надо хоть немного поспать
